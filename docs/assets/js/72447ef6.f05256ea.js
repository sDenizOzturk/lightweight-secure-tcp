"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[352],{2844:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>h,default:()=>o,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"internals/handshake-flow","title":"Handshake Flow","description":"LightweightSecureTCP performs a custom three-step handshake to establish a mutually authenticated and encrypted session.","source":"@site/docs/internals/handshake-flow.md","sourceDirName":"internals","slug":"/internals/handshake-flow","permalink":"/lightweight-secure-tcp/docs/internals/handshake-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/lightweight-secure-tcp/tree/main/docusaurus/docs/internals/handshake-flow.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Handshake Flow","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Internals","permalink":"/lightweight-secure-tcp/docs/category/internals"},"next":{"title":"LightweightSecureTCP Packets","permalink":"/lightweight-secure-tcp/docs/category/lightweightsecuretcp-packets"}}');var t=s(4848),r=s(8453);const a={title:"Handshake Flow",sidebar_position:1},h="Handshake Flow",c={},l=[{value:"\ud83d\udd10 Why Handshake is Necessary",id:"-why-handshake-is-necessary",level:2},{value:"\ud83d\udce6 Handshake Packet Sequence",id:"-handshake-packet-sequence",level:2},{value:"\ud83d\udd04 After a Successful Handshake",id:"-after-a-successful-handshake",level:2},{value:"\u274c What Happens on Failure?",id:"-what-happens-on-failure",level:2},{value:"\u2705 Summary",id:"-summary",level:2}];function d(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"handshake-flow",children:"Handshake Flow"})}),"\n",(0,t.jsxs)(n.p,{children:["LightweightSecureTCP performs a custom three-step handshake to establish ",(0,t.jsx)(n.strong,{children:"a mutually authenticated and encrypted session"}),".",(0,t.jsx)(n.br,{}),"\n","Unlike plain TCP, this ensures that both parties ",(0,t.jsx)(n.strong,{children:"know the shared key"})," and are authorized to proceed."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-why-handshake-is-necessary",children:"\ud83d\udd10 Why Handshake is Necessary"}),"\n",(0,t.jsxs)(n.p,{children:["TCP alone does not provide authentication or encryption.",(0,t.jsx)(n.br,{}),"\n","The handshake in LightweightSecureTCP addresses this by:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Verifying that both client and server possess the same ",(0,t.jsx)(n.strong,{children:"256-bit handshake key"})]}),"\n",(0,t.jsx)(n.li,{children:"Preventing unauthorized devices from connecting"}),"\n",(0,t.jsxs)(n.li,{children:["Generating a ",(0,t.jsx)(n.strong,{children:"temporary session key"})," unique to each connection"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If the handshake fails, the connection is closed immediately and no session is created."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-handshake-packet-sequence",children:"\ud83d\udce6 Handshake Packet Sequence"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Client \u2192 Server"}),"\nSends ",(0,t.jsx)(n.code,{children:"HandshakeRequest"})," containing:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A 32-bit random nonce"}),"\n",(0,t.jsxs)(n.li,{children:["Two 64-bit random numbers\n",(0,t.jsx)(n.em,{children:"(The payload is encrypted using the static key)"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Server \u2192 Client"}),"\nSends ",(0,t.jsx)(n.code,{children:"HandshakeResponse"})," containing:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The encrypted sum and XOR of the received numbers (verifies client\u2019s data)"}),"\n",(0,t.jsxs)(n.li,{children:["A new 32-bit challenge nonce for the client\n",(0,t.jsx)(n.em,{children:"(Payload is encrypted using the static key)"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Client \u2192 Server"}),"\nSends ",(0,t.jsx)(n.code,{children:"HandshakeSuccess"})," containing:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A newly generated session key (for future communication)"}),"\n",(0,t.jsx)(n.li,{children:"Encrypted using the static key"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 If all validations pass, the handshake is ",(0,t.jsx)(n.strong,{children:"complete"})," and the session is securely established."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-after-a-successful-handshake",children:"\ud83d\udd04 After a Successful Handshake"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Client"})," gains access to the communication channel"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Server"})," creates a ",(0,t.jsx)(n.code,{children:"Session"})," object and calls ",(0,t.jsx)(n.code,{children:"onHandshakeSuccess(...)"})]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"new session key"})," is generated by the server after the successful handshake"]}),"\n",(0,t.jsx)(n.li,{children:"Messages are encrypted using this session key"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-what-happens-on-failure",children:"\u274c What Happens on Failure?"}),"\n",(0,t.jsx)(n.p,{children:"If any step fails (invalid encryption, wrong key, timeout, malformed packet):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The handshake is ",(0,t.jsx)(n.strong,{children:"immediately aborted"})]}),"\n",(0,t.jsx)(n.li,{children:"The socket is closed"}),"\n",(0,t.jsxs)(n.li,{children:["The callback ",(0,t.jsx)(n.code,{children:"onHandshakeFailed(...)"})," is triggered on both client and server"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"No session is created, and no data is exchanged."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-summary",children:"\u2705 Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All connections must complete this three-step handshake before any messaging"}),"\n",(0,t.jsxs)(n.li,{children:["This process ensures ",(0,t.jsx)(n.strong,{children:"mutual trust"}),", ",(0,t.jsx)(n.strong,{children:"key validation"}),", and ",(0,t.jsx)(n.strong,{children:"unique per-session encryption"})]}),"\n",(0,t.jsx)(n.li,{children:"Requires calling:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"LightweightSecureTCP::setHandshakeKey(handshakeKey);\n"})}),"\n",(0,t.jsx)(n.p,{children:"on both devices before starting client or server"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["Ready to learn how each of these 3 packets work? \u2192\nCheck out: ",(0,t.jsx)(n.a,{href:"./lightweightsecuretcp-packets/handshake-request",children:"LightweightSecureTCP Packets"})]})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>h});var i=s(6540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);