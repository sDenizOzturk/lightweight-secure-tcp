"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[233],{4153:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>a,frontMatter:()=>c,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"reference/core-lightweightsecureclient","title":"LightweightSecureClient","description":"A secure TCP client that connects to a remote server, performs handshake, sends messages, and handles asynchronous communication.","source":"@site/docs/reference/core-lightweightsecureclient.md","sourceDirName":"reference","slug":"/reference/core-lightweightsecureclient","permalink":"/lightweight-secure-tcp/docs/reference/core-lightweightsecureclient","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/lightweight-secure-tcp/tree/main/docusaurus/docs/reference/core-lightweightsecureclient.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"LightweightSecureClient","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Session","permalink":"/lightweight-secure-tcp/docs/reference/core-session"},"next":{"title":"Key","permalink":"/lightweight-secure-tcp/docs/reference/encryption-key"}}');var t=s(4848),i=s(8453);const c={title:"LightweightSecureClient",sidebar_position:4},d="LightweightSecureClient",l={},o=[{value:"Constructor",id:"constructor",level:2},{value:"LightweightSecureClient",id:"lightweightsecureclient-1",level:3},{value:"Destructor",id:"destructor",level:2},{value:"~LightweightSecureClient",id:"lightweightsecureclient-2",level:3},{value:"Methods",id:"methods",level:2},{value:"setKeepAliveConfig",id:"setkeepaliveconfig",level:3},{value:"connectToServer",id:"connecttoserver",level:3},{value:"disconnect",id:"disconnect",level:3},{value:"sendMessage",id:"sendmessage",level:3},{value:"isConnected",id:"isconnected",level:3},{value:"Event Callback Setters",id:"event-callback-setters",level:2},{value:"setOnConnected",id:"setonconnected",level:3},{value:"setOnDisconnected",id:"setondisconnected",level:3},{value:"setOnMessageReceived",id:"setonmessagereceived",level:3},{value:"setOnHandshakeSuccess",id:"setonhandshakesuccess",level:3},{value:"setOnHandshakeFailed",id:"setonhandshakefailed",level:3},{value:"setOnError",id:"setonerror",level:3},{value:"setOnDataSent",id:"setondatasent",level:3},{value:"Related",id:"related",level:2}];function h(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"lightweightsecureclient",children:"LightweightSecureClient"})}),"\n",(0,t.jsx)(n.p,{children:"A secure TCP client that connects to a remote server, performs handshake, sends messages, and handles asynchronous communication."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,t.jsx)(n.h3,{id:"lightweightsecureclient-1",children:"LightweightSecureClient"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," \u2014 (constructor)"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"const std::string& serverIp"})," \u2014 IP address of the server to connect to"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"int port"})," \u2014 TCP port of the server"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Initializes the socket and performs internal validation.",(0,t.jsx)(n.br,{}),"\n","Terminates the program with ",(0,t.jsx)(n.code,{children:"exit()"})," if encryption key is not set."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"destructor",children:"Destructor"}),"\n",(0,t.jsx)(n.h3,{id:"lightweightsecureclient-2",children:"~LightweightSecureClient"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"})]}),"\n",(0,t.jsxs)(n.p,{children:["Disconnects the socket and triggers ",(0,t.jsx)(n.code,{children:'onError("Client destroyed")'})," if defined."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"setkeepaliveconfig",children:"setKeepAliveConfig"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"int keepAliveIntervalMs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"int inactivityTimeoutMs"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Sets the keep-alive and timeout configuration.",(0,t.jsx)(n.br,{}),"\n","Throws ",(0,t.jsx)(n.code,{children:"std::invalid_argument"})," if values are invalid or inconsistent."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"connecttoserver",children:"connectToServer"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"bool"})]}),"\n",(0,t.jsxs)(n.p,{children:["Attempts to connect to the server and perform handshake.",(0,t.jsx)(n.br,{}),"\n","Returns ",(0,t.jsx)(n.code,{children:"true"})," on success, ",(0,t.jsx)(n.code,{children:"false"})," otherwise.",(0,t.jsx)(n.br,{}),"\n","Triggers:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onConnected()"})," if successful"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'onError("Connection failed")'})," if not"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"disconnect",children:"disconnect"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"})]}),"\n",(0,t.jsxs)(n.p,{children:["Sends a disconnect packet if connected and then closes the socket.",(0,t.jsx)(n.br,{}),"\n","Triggers ",(0,t.jsx)(n.code,{children:"onDisconnected()"})," if defined."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"sendmessage",children:"sendMessage"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"const std::string& message"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Encrypts and sends a message to the server.",(0,t.jsx)(n.br,{}),"\n","Triggers ",(0,t.jsx)(n.code,{children:"onDataSent()"})," if successful, ",(0,t.jsx)(n.code,{children:"onError()"})," if not."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"isconnected",children:"isConnected"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"bool"})]}),"\n",(0,t.jsxs)(n.p,{children:["Returns ",(0,t.jsx)(n.code,{children:"true"})," if the socket is connected and active."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"event-callback-setters",children:"Event Callback Setters"}),"\n",(0,t.jsx)(n.h3,{id:"setonconnected",children:"setOnConnected"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void()> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when the client successfully connects to the server."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"setondisconnected",children:"setOnDisconnected"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void()> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when the connection is lost or disconnected manually."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"setonmessagereceived",children:"setOnMessageReceived"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void(const std::string&)> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when a valid message is received from the server."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"setonhandshakesuccess",children:"setOnHandshakeSuccess"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void(const HandshakeResult&)> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when the handshake with the server succeeds."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"setonhandshakefailed",children:"setOnHandshakeFailed"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void(const HandshakeResult&)> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when the handshake with the server fails."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"setonerror",children:"setOnError"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void(const std::string&)> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called when any error occurs during connection or communication."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"setondatasent",children:"setOnDataSent"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return type:"})," ",(0,t.jsx)(n.code,{children:"void"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Parameters:"})," ",(0,t.jsx)(n.code,{children:"std::function<void(const std::string&)> callback"})]}),"\n",(0,t.jsx)(n.p,{children:"Called after a message is successfully sent to the server."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"./core-lightweightsecureserver",children:"LightweightSecureServer"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"./lightweightsecuretcp",children:"LightweightSecureTCP"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"./core-session",children:"Session"})}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>d});var r=s(6540);const t={},i=r.createContext(t);function c(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);