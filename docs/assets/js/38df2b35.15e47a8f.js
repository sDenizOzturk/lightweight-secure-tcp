"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[840],{4470:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>d,default:()=>a,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"reference/core-session","title":"Session","description":"Represents a secure communication session between the server and a connected client.","source":"@site/docs/reference/core-session.md","sourceDirName":"reference","slug":"/reference/core-session","permalink":"/lightweight-secure-tcp/docs/reference/core-session","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/lightweight-secure-tcp/tree/main/docusaurus/docs/reference/core-session.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Session","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"LightweightSecureServer","permalink":"/lightweight-secure-tcp/docs/reference/core-lightweightsecureserver"},"next":{"title":"LightweightSecureClient","permalink":"/lightweight-secure-tcp/docs/reference/core-lightweightsecureclient"}}');var r=n(4848),t=n(8453);const c={title:"Session",sidebar_position:3},d="Session",l={},o=[{value:"Methods",id:"methods",level:2},{value:"isActive",id:"isactive",level:3},{value:"sessionKey",id:"sessionkey",level:3},{value:"sendMessage",id:"sendmessage",level:3},{value:"disconnect",id:"disconnect",level:3},{value:"Event Callback Setters",id:"event-callback-setters",level:2},{value:"setOnMessageReceived",id:"setonmessagereceived",level:3},{value:"setOnSessionEnded",id:"setonsessionended",level:3},{value:"setOnError",id:"setonerror",level:3},{value:"setOnDataSent",id:"setondatasent",level:3},{value:"Notes",id:"notes",level:2}];function h(e){const s={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"session",children:"Session"})}),"\n",(0,r.jsxs)(s.p,{children:["Represents a secure communication session between the server and a connected client.",(0,r.jsx)(s.br,{}),"\n","Created after a successful handshake, this class handles messaging, disconnection, and event callbacks. ",(0,r.jsx)(s.code,{children:"onSessionEnded()"})," if it was set."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(s.h3,{id:"isactive",children:"isActive"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"bool"})]}),"\n",(0,r.jsxs)(s.p,{children:["Returns ",(0,r.jsx)(s.code,{children:"true"})," if the session is still alive and not closed."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"sessionkey",children:"sessionKey"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"const Key&"})]}),"\n",(0,r.jsx)(s.p,{children:"Returns the encryption key negotiated during the handshake."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"sendmessage",children:"sendMessage"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"void"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"const std::string& message"})}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Encrypts and sends a message over the socket using the session key.",(0,r.jsx)(s.br,{}),"\n","Triggers ",(0,r.jsx)(s.code,{children:"onDataSent()"})," if sending is successful.",(0,r.jsx)(s.br,{}),"\n","Triggers ",(0,r.jsx)(s.code,{children:"onError()"})," if sending fails."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"disconnect",children:"disconnect"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"void"})]}),"\n",(0,r.jsxs)(s.p,{children:["Sends a disconnect packet and shuts down the session.",(0,r.jsx)(s.br,{}),"\n","Also calls ",(0,r.jsx)(s.code,{children:"onSessionEnded()"}),"."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"event-callback-setters",children:"Event Callback Setters"}),"\n",(0,r.jsx)(s.h3,{id:"setonmessagereceived",children:"setOnMessageReceived"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"void"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"std::function<void(const std::string&)> callback"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Called when a valid message is received."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"setonsessionended",children:"setOnSessionEnded"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"void"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"std::function<void()> callback"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Called when the session is closed (either locally or by the client)."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"setonerror",children:"setOnError"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"void"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"std::function<void(const std::string& errorMessage)> callback"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Called when an error occurs during communication."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"setondatasent",children:"setOnDataSent"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Return type:"})," ",(0,r.jsx)(s.code,{children:"void"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"std::function<void(const std::string&)> callback"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Called after a message has been successfully sent."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"The session automatically terminates if the connection is lost, the remote disconnects, or keep-alive checks fail."}),"\n",(0,r.jsx)(s.li,{children:"All callbacks are optional."}),"\n",(0,r.jsxs)(s.li,{children:["Session state can be queried with ",(0,r.jsx)(s.code,{children:"isActive()"}),"."]}),"\n"]})]})}function a(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>d});var i=n(6540);const r={},t=i.createContext(r);function c(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);